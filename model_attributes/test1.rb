
  
module AttributeMethods

  NAME_COMPILABLE_REGEXP = /\A[a-zA-Z_]\w*[!?=]?\z/
  CALL_COMPILABLE_REGEXP = /\A[a-zA-Z_]\w*[!?]?\z/

  # 保存属性方法匹配对象的集合
  @attribute_method_matchers = []
  #class_attribute :attribute_method_matchers, :instance_writer => false
  self.attribute_method_matchers = [ClassMethods::AttributeMethodMatcher.new]

  module ClassMethods
    # 为属性定义方法
    def define_attr_method(name, value=nil, deprecation_warning = true, &block) #:nodoc:
      if deprecation_warning
        puts "define_attr_method is deprecated and will be removed without replacement."
      end

      # 访问original_#{name}时，提示过时信息
      # 调用#{name}方法
      sing = singleton_class
      sing.class_eval <<-eorb, __FILE__, __LINE__ + 1
        remove_possible_method :'original_#{name}'
        remove_possible_method :'_original_#{name}'
        alias_method :'_original_#{name}', :'#{name}'
        define_method :'original_#{name}' do
          ActiveSupport::Deprecation.warn(
            "This method is generated by ActiveModel::AttributeMethods::ClassMethods#define_attr_method, " \
            "which is deprecated and will be removed."
          )
          send(:'_original_#{name}')
        end
      eorb

      if block_given?
        sing.send :define_method, name, &block
      else
        if name =~ NAME_COMPILABLE_REGEXP
          sing.class_eval <<-RUBY, __FILE__, __LINE__ + 1
            def #{name}; #{value.nil? ? 'nil' : value.to_s.inspect}; end
          RUBY
        else
          value = value.to_s if value
          sing.send(:define_method, name) { value }
        end
      end
    end

    # 声明可用于指定前缀的所有属性方法
    def attribute_method_prefix(*prefixes)
      self.attribute_method_matchers += prefixes.map { |prefix| AttributeMethodMatcher.new :prefix => prefix }
      undefine_attribute_methods
    end

    # 声明具有指定后缀的所有属性方法
    def attribute_method_suffix(*suffixes)
      self.attribute_method_matchers += suffixes.map { |suffix| AttributeMethodMatcher.new :suffix => suffix }
      undefine_attribute_methods
    end

    # 声明可用于给定前缀和后缀的所有属性的方法
    def attribute_method_affix(*affixes)
      self.attribute_method_matchers += affixes.map { |affix| AttributeMethodMatcher.new :prefix => affix[:prefix], :suffix => affix[:suffix] }
      undefine_attribute_methods
    end

    # 定义别名属性方法
    def alias_attribute(new_name, old_name)
      attribute_method_matchers.each do |matcher|
        matcher_new = matcher.method_name(new_name).to_s
        matcher_old = matcher.method_name(old_name).to_s
        define_optimized_call self, matcher_new, matcher_old
      end
    end

    # 定义一组属性方法
    def define_attribute_methods(attr_names)
      attr_names.each { |attr_name| define_attribute_method(attr_name) }
    end

    # 定义attribute_method属性方法
    def define_attribute_method(attr_name)
      attribute_method_matchers.each do |matcher|
        method_name = matcher.method_name(attr_name)

        unless instance_method_already_implemented?(method_name)
          generate_method = "define_method_#{matcher.method_missing_target}"

          if respond_to?(generate_method, true)
            send(generate_method, attr_name)
          else
            define_optimized_call generated_attribute_methods, method_name, matcher.method_missing_target, attr_name.to_s
          end
        end
      end
      attribute_method_matchers_cache.clear
    end

    def undefine_attribute_methods
      generated_attribute_methods.module_eval do
        instance_methods.each { |m| undef_method(m) }
      end
      attribute_method_matchers_cache.clear
    end

    def generated_attribute_methods #:nodoc:
      @generated_attribute_methods ||= begin
        mod = Module.new
        include mod
        mod
      end
    end

    protected
      # 方法是否已存在于@generated_attribute_methods中
      def instance_method_already_implemented?(method_name)
        generated_attribute_methods.method_defined?(method_name)
      end

    private
      def attribute_method_matchers_cache #:nodoc:
        @attribute_method_matchers_cache ||= {}
      end

      def attribute_method_matcher(method_name) #:nodoc:
        if attribute_method_matchers_cache.key?(method_name)
          attribute_method_matchers_cache[method_name]
        else
          matchers = attribute_method_matchers.partition(&:plain?).reverse.flatten(1)
          match = nil
          matchers.detect { |method| match = method.match(method_name) }
          attribute_method_matchers_cache[method_name] = match
        end
      end

      # 优化方法调用,调用name，实际响应者是send
      # 
      def define_optimized_call(mod, name, send, *extra) #:nodoc:
        if name =~ NAME_COMPILABLE_REGEXP
          defn = "def #{name}(*args)"
        else
          defn = "define_method(:'#{name}') do |*args|"
        end

        extra = (extra.map(&:inspect) << "*args").join(", ")

        if send =~ CALL_COMPILABLE_REGEXP
          target = "#{send}(#{extra})"
        else
          target = "send(:'#{send}', #{extra})"
        end

        mod.module_eval <<-RUBY, __FILE__, __LINE__ + 1
          #{defn}
            #{target}
          end
        RUBY
      end

      # 属性方法匹配类
      class AttributeMethodMatcher
        attr_reader :prefix, :suffix, :method_missing_target

        AttributeMethodMatch = Struct.new(:target, :attr_name, :method_name)

        def initialize(options = {})
          options.symbolize_keys!

          if options[:prefix] == '' || options[:suffix] == ''
            ActiveSupport::Deprecation.warn(
              "Specifying an empty prefix/suffix for an attribute method is no longer " \
              "necessary. If the un-prefixed/suffixed version of the method has not been " \
              "defined when `define_attribute_methods` is called, it will be defined " \
              "automatically."
            )
          end

          @prefix, @suffix = options[:prefix] || '', options[:suffix] || ''
          @regex = /\A(#{Regexp.escape(@prefix)})(.+?)(#{Regexp.escape(@suffix)})\z/
          @method_missing_target = "#{@prefix}attribute#{@suffix}"
          @method_name = "#{prefix}%s#{suffix}"
        end

        def match(method_name)
          if @regex =~ method_name
            AttributeMethodMatch.new(method_missing_target, $2, method_name)
          else
            nil
          end
        end

        # 获取生成的属性名称
        def method_name(attr_name)
          @method_name % attr_name
        end

        # 前缀和后缀是否为空
        def plain?
          prefix.empty? && suffix.empty?
        end
      end
  end # ClassMethods .. end

  def method_missing(method, *args, &block)
    if respond_to_without_attributes?(method, true)
      super
    else
      match = match_attribute_method?(method.to_s)
      match ? attribute_missing(match, *args, &block) : super
    end
  end

  def attribute_missing(match, *args, &block)
    __send__(match.target, match.attr_name, *args, &block)
  end

  alias :respond_to_without_attributes? :respond_to? # respond_to_without_attributes? 指向之前的旧方法
  def respond_to?(method, include_private_methods = false)
    if super
      true
    elsif !include_private_methods && super(method, true)
      false
    else
      !match_attribute_method?(method.to_s).nil?
    end
  end

  protected
    def attribute_method?(attr_name)
      respond_to_without_attributes?(:attributes) && attributes.include?(attr_name)
    end

  private
    def match_attribute_method?(method_name)
      match = self.class.send(:attribute_method_matcher, method_name)
      match && attribute_method?(match.attr_name) ? match : nil
    end

    def missing_attribute(attr_name, stack)
      raise ActiveModel::MissingAttributeError, "missing attribute: #{attr_name}", stack
    end
end

class Mac
  include AttributeMethods
  extend AttributeMethods::ClassMethods


end
